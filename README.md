# go-concslice
Go library for parallel slice processing with context support, state management, and configurable concurrency. Easy worker control.

### Основные возможности

#### Параллельная обработка
- **Генерализованная обработка слайсов**: Поддержка любых типов данных через Go generics
- **Автоматическое управление воркерами**: Автоматическое определение оптимального количества воркеров (GOMAXPROCS)
- **Потокобезопасность**: Все операции синхронизированы с использованием sync.Mutex

#### Управление состоянием
- **Встроенное состояние**: Поддержка пользовательского состояния с типизацией
- **Атомарные операции**: Безопасные операции с состоянием в многопоточной среде
- **Callback функции**: Возможность выполнения кода при завершении обработки

#### Контекстная поддержка
- **Отмена операций**: Полная интеграция с Go context для отмены
- **Таймауты**: Поддержка контекстных таймаутов
- **Graceful shutdown**: Корректное завершение работы воркеров

### API функции

#### Основные функции
- `Process[Item, State]()` - запуск параллельной обработки элементов слайса
- `NewProcessor[Item, State]()` - создание процессора с предустановленными настройками

#### Управление задачами
- `Wait()` - ожидание завершения обработки с возвратом Result
- `Cancel()` - отмена текущей обработки
- `Context()` - получение контекста задачи

#### Информация о состоянии
- `ProcessedCount` - количество обработанных элементов (через Result)
- `MaxWorkers()` - максимальное количество воркеров
- `IsCanceled` - статус отмены (через Result)

#### Настройки (Options)
- `WithMaxWorkers[State](concurrency int)` - установка количества воркеров
- `WithOnFinish[State](onFinish func(State))` - callback при завершении
- `WithState[State](state State)` - установка начального состояния
- `WithStateFunc[State](fn func(*Task[State]) State)` - установка состояния через функцию

### Технические детали

#### Структуры данных
- **`Task[State]`** - основная структура задачи с состоянием
- **`Result[State]`** - результат обработки с состоянием и метаданными
- **`Processor[Item, State]`** - процессор с предустановленными настройками

#### Обработка ошибок
- **Recovery от паник**: Встроенная обработка паник в воркерах
- **Graceful degradation**: Корректная обработка пустых слайсов
- **Контекстные ошибки**: Обработка ошибок контекста (отмена, таймаут)

#### Производительность
- **Оптимизация воркеров**: Автоматическое ограничение количества воркеров размером слайса
- **Эффективная синхронизация**: Минимальное использование блокировок
- **Память**: Эффективное управление памятью с автоматической очисткой ресурсов

### Тестирование

#### Покрытие тестами
- **Базовые сценарии**: Обработка с одним и несколькими воркерами
- **Граничные случаи**: Пустые слайсы, нулевая параллельность
- **Отмена операций**: Тестирование отмены через контекст и Cancel()
- **Таймауты**: Тестирование обработки таймаутов
- **Различные типы**: Тестирование с разными типами данных (int64, string, struct)

#### Тестовые сценарии
- Суммирование элементов с одним воркером
- Параллельная обработка 1000 элементов
- Обработка слайсов меньше количества воркеров
- Обработка пустых слайсов
- Отмена через контекст
- Отмена через Cancel()
- Callback функции при завершении
- Обработка различных типов данных
- Обработка строковых данных
- Таймауты обработки

### Примеры использования

```go
// Простая обработка с суммированием
result := Process(ctx, items, func(task *Task[int], item int) {
    task.State += item
}, WithMaxWorkers[int](4))

// С callback при завершении
result := Process(ctx, items, handler, 
    WithOnFinish[int](func(state int) {
        fmt.Printf("Обработано элементов: %d\n", state)
    }))

// Обработка пользовательских типов
type Person struct { Name string; Age int }
type Stats struct { TotalAge int }

people := []Person{{"Alice", 25}, {"Bob", 30}}
result := Process(ctx, people, func(task *Task[Stats], person Person) {
    task.State.TotalAge += person.Age
})
```

### Зависимости
- **Go 1.23+** - минимальная версия Go
- **github.com/stretchr/testify v1.11.1** - для тестирования